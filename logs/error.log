{"error":"Request failed with status code 400. Error: Invalid regular expression: /*/search*/: Nothing to repeat ","level":"error","message":"Firecrawl crawl error","timestamp":"2025-06-29 14:49:28","url":"https://interviewing.io/blog"}
{"level":"error","message":"No data returned from Firecrawl","timestamp":"2025-06-29 16:16:48","url":"https://drive.google.com/file/d/1Udr6zhDxF-LEqxti15UAfe-_vriggdRO/view?usp=sharing"}
{"error":"Failed to scrape URL. Status code: 400. Error: Bad Request - [{\"code\":\"unrecognized_keys\",\"keys\":[\"screenshot\"],\"path\":[],\"message\":\"Unrecognized key in body -- please review the v1 API documentation for request body changes\"}]","level":"error","message":"Advanced extraction error","timestamp":"2025-06-29 16:17:00","url":"https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array"}
{"level":"error","message":"No data returned from Firecrawl","timestamp":"2025-06-29 16:17:27","url":"https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array"}
{"level":"error","message":"No data returned from Firecrawl","timestamp":"2025-06-29 16:17:37","url":"https://nilmamano.com/blog/binary-search"}
{"level":"error","message":"No data returned from Firecrawl","timestamp":"2025-06-29 16:18:16","url":"https://nilmamano.com/blog/binary-search"}
{"level":"error","message":"No data returned from Firecrawl","scrapeResult":"{\n  \"success\": true,\n  \"warning\": \"The engine used does not support the following features: waitFor -- your scrape may be partial.\",\n  \"markdown\": \"[‚Üê Back to all posts](https://nilmamano.com/blog)\\n\\nGet Binary Search Right Every Time, Explained Without Code\\n==========================================================\\n\\nApril 15, 2025\\n\\n![Get Binary Search Right Every Time, Explained Without Code](https://nilmamano.com/blog/binary-search/cover.png)\\n\\nOne of the things that makes binary search tricky to implement is that you usually need to tweak the pointer manipulation logic in subtle ways based on the specifics of the problem.\\n\\nE.g., an implementation that works for finding a target in a sorted array when the target is present, may not work if the target is missing. Or, it may not be clear how to tweak the code to find the last occurrence of the target instead of the first one. And of course, there are plenty of less conventional applications of binary search where the input is not an array, like [catching bike thieves](https://x.com/AlecStapp/status/1728953538301345889)\\n.\\n\\nIn [Beyond Cracking the Coding Interview](https://www.amazon.com/dp/195570600X)\\n, we wanted to simplify this, so we went looking for a general binary search template. Going into it, I thought we might need at least two templates, but we ended up with just one, which we called the \\\"transition point recipe\\\", and which works for every problem we tried, including the 17 problems in the binary search chapter of the book. If you find one where it doesn't work, let me know!\\n\\nThe transition point problem\\n----------------------------\\n\\nHere is the thesis of the transition point recipe:\\n\\nEvery binary search problem can be reduced to the 'transition point problem'.\\n\\nIn the 'transition point problem', you are given an array with just two values, say `1` and `2`, where all the `1`s come before the `2`s, and you need to point where it changes.\\n\\nE.g., in the array `[1, 1, 1, 1, 1, 2, 2, 2]`, the last `1` is at index `4` and the first `2` is at index `5`.\\n\\nKnowing how to solve this specific problem is key to our recipe. The specific binary search implementation is not important, but there is an invariant we can follow that makes it quite easy: ensure that the left pointer is always at a `1` and the right pointer is always at a `2`.\\n\\nWe give code in the book, but remembering exact code in an interview is error prone. Instead, the four bullet points below are all I _personally_ remember, and I feel confident that I can derive the rest easily.\\n\\n1.  Start by handling some edge cases:\\n    *   The array is empty\\n    *   Every value is `1`\\n    *   Every value is `2`\\n2.  Initialize two pointers, `left` and `right`, to the first and last indices, respectively.\\n3.  For the main binary search loop, always maintain the _invariant_ that the value at `left` is `1` and the value at `right` is `2`. Let this invariant guide your pointer manipulation logic, so that you don't need to memorize any code.\\n4.  Stop when the `left` and `right` pointers are next to each other (i.e., `left + 1 == right`).\\n\\nCombining the invariant with the stopping condition, we get that, at the end, `left` will be at the last `1` and `right` will be at the first `2`.\\n\\nThese bullet points rely on two ideas to make binary search easier: (1) handling edge cases upfront, and (2) letting strong invariants guide the implementation. Notice how the invariant even guides the edge cases at the beginning, as they are the necessary ones to be able to initialize `left` and `right` in a way that satisfies it.\\n\\nThe reduction\\n-------------\\n\\nOk, so now, let's take for granted that we can solve the transition point problem. How does this help us solve other binary search problems?\\n\\nThe idea is to come up with a (problem-specific) _predicate_, like `< target`, `>= target`, or `x % 2 == 0`, which splits the search range into two regions, the \\\"before\\\" region and the \\\"after\\\" region.\\n\\nThis predicate is a function that takes an element of the search range and returns a boolean, and -- as you probably saw coming -- it is key that all the elements with `true` values come before the elements with `false` values (or the other way around).\\n\\nThen, we can use the solution to the transition point problem to find the transition point between the 'before' and 'after' regions. The only difference is that, instead of checking boolean values directly, we check the result of the predicate.\\n\\nYou can even wrap the predicate in a function, which we called `is_before(x)` in the book, which tells you whether a given element is in the 'before' region. Then, it's really obvious that we are just solving the transition point problem every time.\\n\\nThe only part that requires some thinking is choosing the right transition point. For example:\\n\\n*   if we want to find the _first_ occurrence of `target` in a sorted array, we can use `is_before(x) = x < target`, which means that, if `target` is present, the first occurrence is the first element in the 'after' region (so, we can check/return the `right` pointer at the end).\\n*   if we want to find the _last_ occurrence of `target` in a sorted array, we can use `is_before(x) = x <= target`, which means that, if `target` is present, the last occurrence is the last element in the 'before' region (so, we can check/return the `left` pointer at the end).\\n\\nAnd so on for other problems.\\n\\n![Binary search recipe](https://nilmamano.com/blog/binary-search/meme.png)\\n\\nPractice\\n--------\\n\\nYou can try the transition-point recipe on all the problems from the binary search chapter of the book online at [start.interviewing.io/beyond-ctci/part-vii-catalog/binary-search](https://start.interviewing.io/beyond-ctci/part-vii-catalog/binary-search)\\n, even if you don't have the book. There, you can also find all our solutions using the recipe, in Python, JS, Java, and C++.\\n\\nBy the way, the binary search chapter of the book is free -- it's in [bctci.co/free-chapters](https://bctci.co/free-chapters)\\n.\\n\\n_Want to leave a comment? You can post under the [linkedin post](https://www.linkedin.com/posts/nilmamano_get-binary-search-right-every-time-explained-activity-7319072161481084932-74ga?utm_source=share&utm_medium=member_desktop&rcm=ACoAAC6jqIwBADV70xmTEpmkxbAnN_32mssoxA8)\\n or the [X post](https://x.com/Nil053/status/1913316583298011224)\\n._\",\n  \"metadata\": {\n    \"twitter:image\": \"https://nilmamano.com/blog/binary-search/cover.png\",\n    \"og:image:height\": \"630\",\n    \"language\": \"en\",\n    \"og:description\": \"A binary search recipe that works for every problem, explained without code.\",\n    \"og:title\": \"Get Binary Search Right Every Time, Explained Without Code\",\n    \"theme-color\": \"#ffffff\",\n    \"ogTitle\": \"Get Binary Search Right Every Time, Explained Without Code\",\n    \"og:image:width\": \"1200\",\n    \"ogImage\": \"https://nilmamano.com/blog/binary-search/cover.png\",\n    \"next-size-adjust\": \"\",\n    \"favicon\": \"https://nilmamano.com/favicon.ico\",\n    \"article:published_time\": \"2025-04-15\",\n    \"twitter:title\": \"Get Binary Search Right Every Time, Explained Without Code\",\n    \"description\": \"A binary search recipe that works for every problem, explained without code.\",\n    \"og:url\": \"https://nilmamano.com/blog/binary-search\",\n    \"title\": \"Get Binary Search Right Every Time, Explained Without Code\",\n    \"og:image\": \"https://nilmamano.com/blog/binary-search/cover.png\",\n    \"viewport\": \"width=device-width, initial-scale=1\",\n    \"og:type\": \"article\",\n    \"ogUrl\": \"https://nilmamano.com/blog/binary-search\",\n    \"publishedTime\": \"2025-04-15\",\n    \"ogDescription\": \"A binary search recipe that works for every problem, explained without code.\",\n    \"twitter:card\": \"summary_large_image\",\n    \"og:image:alt\": \"Get Binary Search Right Every Time, Explained Without Code\",\n    \"twitter:description\": \"A binary search recipe that works for every problem, explained without code.\",\n    \"scrapeId\": \"4b645518-1eb4-40b8-85f5-83158618ba45\",\n    \"sourceURL\": \"https://nilmamano.com/blog/binary-search\",\n    \"url\": \"https://nilmamano.com/blog/binary-search\",\n    \"statusCode\": 200,\n    \"contentType\": \"text/html; charset=utf-8\",\n    \"proxyUsed\": \"basic\",\n    \"creditsUsed\": 1\n  }\n}","timestamp":"2025-06-29 16:18:46","url":"https://nilmamano.com/blog/binary-search"}
{"error":"Request failed with status code 400. Error: Invalid regular expression: /*interview-questions*/: Nothing to repeat ","level":"error","message":"Firecrawl crawl error","timestamp":"2025-06-29 16:24:18","url":"https://interviewing.io/topics"}
{"error":"Request failed with status code 400. Error: Bad Request  - [{\"code\":\"unrecognized_keys\",\"keys\":[\"allowBackwardCrawling\",\"allowExternalContentLinks\"],\"path\":[],\"message\":\"Unrecognized key in body -- please review the v1 API documentation for request body changes\"}]","level":"error","message":"Firecrawl crawl error","timestamp":"2025-06-29 16:57:08","url":"https://interviewing.io/topics"}
{"error":"AggregateError","level":"error","message":"Firecrawl crawl error","timestamp":"2025-06-29 17:56:47","url":"https://quill.co/blog"}
{"error":"Request failed with status code 400. Error: Invalid regular expression: /*/docs/*/: Nothing to repeat ","level":"error","message":"Firecrawl crawl error","timestamp":"2025-06-30 02:18:46","url":"https://quill.co/blog"}
{"error":"Failed to scrape URL. Status code: 400. Error: Bad Request - [{\"validation\":\"url\",\"code\":\"invalid_string\",\"message\":\"Invalid url\",\"path\":[\"url\"]},{\"code\":\"custom\",\"message\":\"URL must have a valid top-level domain or be a valid path\",\"path\":[\"url\"]},{\"code\":\"custom\",\"message\":\"Invalid URL\",\"path\":[\"url\"]}]","level":"error","message":"Advanced extraction error","timestamp":"2025-06-30 06:48:48","url":"'+e.props["}
{"error":{"name":"TimeoutError"},"level":"error","message":"Playwright mode failed","timestamp":"2025-06-30 07:15:26"}
{"error":"Unexpected error occurred while trying to scrape URL. Status code: 401","level":"error","message":"Advanced extraction error","timestamp":"2025-06-30 07:30:05","url":"https://quill.co/blog/why-users-want-customer-facing-analytics"}
{"error":"Unexpected error occurred while trying to scrape URL. Status code: 401","level":"error","message":"Advanced extraction error","timestamp":"2025-06-30 07:30:07","url":"https://quill.co/blog/brief-overview-of-the-modern-data-stack"}
{"error":"Unexpected error occurred while trying to scrape URL. Status code: 401","level":"error","message":"Advanced extraction error","timestamp":"2025-06-30 07:30:09","url":"https://quill.co/blog/the-evolution-of-business-intelligence-part-1"}
{"error":"Failed to fetch post: Not Found","level":"error","message":"Failed to extract Substack content","timestamp":"2025-06-30 10:10:08","url":"https://shreycation.substack.com/p/example-post"}
{"error":"Failed to fetch post: Not Found","level":"error","message":"Failed to extract Substack content","timestamp":"2025-06-30 10:10:09","url":"https://shreycation.substack.com/p/paywalled-post"}
{"error":"Failed to fetch post: Not Found","level":"error","message":"Failed to extract Substack content","timestamp":"2025-06-30 10:10:09","url":"https://shreycation.substack.com/p/preview-post"}
{"error":"Cannot read properties of undefined (reading 'audience')","level":"error","message":"Failed to extract Substack content","timestamp":"2025-06-30 10:10:19","url":"https://shreycation.substack.com/p/snacks-its-not-too-late-for-euro"}
{"error":"Failed to fetch post: Not Found","level":"error","message":"Failed to extract Substack content","timestamp":"2025-06-30 10:10:19","url":"https://shreycation.substack.com/p/paywalled-post"}
{"error":"Failed to fetch post: Not Found","level":"error","message":"Failed to extract Substack content","timestamp":"2025-06-30 10:14:51","url":"https://shreycation.substack.com/p/example-post"}
{"error":"Failed to fetch post: Not Found","level":"error","message":"Failed to extract Substack content","timestamp":"2025-06-30 10:14:51","url":"https://shreycation.substack.com/p/paywalled-post"}
{"error":"Failed to fetch post: Not Found","level":"error","message":"Failed to extract Substack content","timestamp":"2025-06-30 10:14:51","url":"https://shreycation.substack.com/p/preview-post"}
{"error":"Cannot read properties of undefined (reading 'audience')","level":"error","message":"Failed to extract Substack content","timestamp":"2025-06-30 10:14:56","url":"https://shreycation.substack.com/p/snacks-its-not-too-late-for-euro"}
{"error":"Failed to fetch post: Not Found","level":"error","message":"Failed to extract Substack content","timestamp":"2025-06-30 10:14:56","url":"https://shreycation.substack.com/p/paywalled-post"}
